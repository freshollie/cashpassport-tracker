import os
import random
import logging
import subprocess
import time
from email import encoders
from email.mime.base import MIMEBase

import smtplib
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import formatdate

import dateutil.tz
import markdown

from api import CashpassportApi, CashpassportApiError, CashpassportApiConnectionError
from transactions import Transaction, TransactionList, format_euros

MAIN_PATH = os.path.dirname(os.path.abspath(__file__))

with open(os.path.join(MAIN_PATH, "css/github.css"), "r") as f:
    MARKDOWN_CSS = str(f.read())

class TrackedAccount:
    def __init__(self, user_id, email, timezone, user_api, user_db):
        self.user_id = user_id
        self.time_zone = dateutil.tz(timezone)
        self.email = email
        self.api = user_api
        self.db = user_db


class CashpassportNotifier:
    DEV = False

    def __init__(self, db_address, mail_server, email_address, email_password):
        self.log = logging.getLogger()

        self._db_address = db_address
        self._mail_server = mail_server
        self._email_address = email_address
        self.__email_password = email_password

        self.__tracked_accounts = {}

    def _make_email_msg(self, tracked_account):
        all_transactions = tracked_account.db.get_transactions()

        content = ""
        content += "# CashPassport Account Update\n"
        content += "---\n"
        content += "## Account balance - " + format_euros(bank_account.get_balance()) + "\n"
        content += "### Spending\n"

        content += "- This week - " + format_euros(all_transactions.this_week().sum()) + "\n"
        content += "- This month - " + format_euros(all_transactions.this_month().sum()) + "\n"
        content += "- This year - " + format_euros(all_transactions.this_year().sum()) + "\n"

        last_20 = list(reversed(tracked_account.db..get_transactions()))[:20]

        if last_20:
            content += "### Last 20 Transactions\n"

            content += "|Date|Type|Place|Amount|\n"
            content += "|-|-|-|-|\n"

            for transaction in last_20:
                type_string = "Unknown type"
                if transaction.get_type() == Transaction.TYPE_PURCHACE:
                    type_string = "Purchase"
                elif transaction.get_type() == Transaction.TYPE_WITHDRAWAL:
                    type_string = "Withdrawal"

                if not transaction.is_verified():
                    type_string += " - Unverified"

                content += "|" + "|".join([
                    transaction.get_date_time().replace(tzinfo=tracked_account.timezone).strftime("%Y-%m-%d %H:%M:%S"),
                    type_string,
                    transaction.get_place(),
                    format_euros(abs(transaction.get_amount()))
                    ]
                ) + "|\n"

        content += "\n*Generated by Cashpassport-Tracker - Oliver Bell - " \
                   "https://github.com/freshollie/cashpassport-tracker*\n"

        self.log.debug("Sending email: ")
        self.log.debug("-------------")
        self.log.debug(content)

        msg = MIMEMultipart()
        msg['To'] = tracked_account.email
        msg['Date'] = formatdate(localtime=True)
        msg['Subject'] = "CashPassport update - Balance: " + format_euros(tracked_account.db..get_balance())
        msg['From'] = self._email_address  # some SMTP servers will do this automatically, not all


        # render the markdown into HTML
        html_content = markdown.markdown(content, ['extra', 'codehilite'])
        html_content = '<style type="text/css">' + \
                       MARKDOWN_CSS + '</style>' + html_content

        msg.attach(MIMEText(html_content, 'html'))

        return msg


    def _send_info_email(self, tracked_account):
        msg = self._make_email_msg(tracked_account)

        if self.DEV:
            return True

        for i in range(3):
            try:
                try:
                    conn = smtplib.SMTP(self._mail_server)
                    conn.set_debuglevel(1)
                    conn.starttls()
                except:
                    conn = smtplib.SMTP(self._mail_server)
                    conn.set_debuglevel(1)

                conn.login(self._email_address, self.__email_password)
                if not self.DEV: conn.sendmail(self._email_address, tracked_account.email, msg.as_string())
                conn.quit()
                self.log.debug("-------------")
                self.log.debug("Succesfully sent!")
                return True
            except smtplib.SMTPException as e:
                self.log.error("Could not send email: " + str(e) + "; " + str(type(e)))

                try:
                    conn.quit()
                except:
                    pass

                if type(e) != smtplib.SMTPServerDisconnected:
                    return False
                self.log.debug("Retrying email in 10 seconds")
                time.sleep(10)

        self.log.error("Error with email")
        return False

    def _update_account(self, tracked_account):
        # Check the account balance to see if it has changed

        self.log.debug("Reading balance of %s" % user_id)
        old_balance = tracked_account.db.get_balance()

        try:
            balance = tracked_account.api.get_balance()
        except Cash

        if balance == CashpassportApi.ERROR_LOGGED_OUT and not self._api.is_logged_in():
            if self._api.login():
                balance = self._api.get_balance()
                if balance == CashpassportApi.ERROR_LOGGED_OUT and not self._api.is_logged_in():
                    self.log("Error getting balance")
                    return False
            else:
                self.log("Login error")
                return False

        if balance != old_balance:
            self.log("New balance: " + str(balance))
            self._bank_account.new_balance(balance)

        self.log("Reading transactions")

        transaction_history = self._bank_account.get_transactions()

        # Find how far back we need to search to get all the information we need about previous transactions
        # We do this by looking through all previous transactions until we hit an unverified transaction
        # Meaning we need to search all the way back to that transaction

        search_until = 0
        for transaction in transaction_history:
            if not transaction.is_verified():
                break
            search_until = transaction.get_epoch_time()

        fetched_transactions = self._api.get_transactions(search_until)

        if fetched_transactions == CashpassportApi.ERROR_LOGGED_OUT:
            if self._api.login():
                fetched_transactions = self._api.get_transactions(search_until)

                if fetched_transactions == CashpassportApi.ERROR_LOGGED_OUT:
                    self.log("Error getting recent transactions")
                    return
            else:
                self.log("Login error")
                return False

        new_transactions = TransactionList()

        # Check if unverified transactions in our history, and remove
        # them from the history if they are not contained in the fetched transactions
        # (Meaning that a transaction has been verified)
        for historic_transaction in transaction_history:
            if not historic_transaction.is_verified():
                found = False
                for recent_transaction in fetched_transactions:
                    if historic_transaction.get_hash() == recent_transaction.get_hash():
                        found = True
                        break

                if not found:
                    self.log("Unverified transaction removed: " + str(historic_transaction))
                    self._bank_account.remove_transaction(historic_transaction)

        for transaction in reversed(fetched_transactions):
            if not self._bank_account.has_transaction(transaction):
                new_transactions.append(transaction)
                self._bank_account.new_transaction(transaction)
                self.log("New verified transaction: " + str(transaction))

        if balance != old_balance or new_transactions:
            if not self.send_info_email():
                return False
        else:
            self.log("No new activity")

        return True

    def get_random_sleep_time(self):
        return random.randint(3*60*60, 5*60*60)

    def random_sleep(self):
        sleep_time = self.get_random_sleep_time()
        self.log("Refreshing in: " + str(sleep_time) + " seconds")
        time.sleep(sleep_time)  # only refresh every 3-5 hours

    def main_loop(self):
        self.log("Main loop started")
        while self.poll():
            self.random_sleep()

def run():
    SpendingTracker.DEV = False

    if credentials:
        tracker = SpendingTracker(credentials)

        if (tracker.get_api().is_logged_in()):
            tracker.main_loop()
            normal_print("Error in main loop, exiting")

if __name__ == "__main__":
    run()
